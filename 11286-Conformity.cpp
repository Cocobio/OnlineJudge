/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2261

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(N*Frosh_max*log(Frosh_max))	: Where N is the number of cases, Frosh_max is the maximum number of students found on the cases
	spatial: O(n)							: Where n is the number of students 

	For the temporal analysis, all the complexities are commented right next to all of the lines. 
	
		=========================================================================================================================================================================
		while (cin >> frosh && frosh != 0)							N times
			for (int student=0; student<frosh; student++)			Frosh_max times
				inside loop => O(1)

				sort(classes) => O(1)

				form string key => O(1)

				count concurrencie => O(1)

			for (auto it=combinations.begin(); it!=combinations.end(); it++)	// At most the number of students
				heap.push => O(log(n)) where n is the current size of the heap

			for pop top concurrencies	// At most it will run the number of students
				pop_top => O(log(n)), where n is at most the number of students

			combinations.clear();						// O(n), where n is the size of the container... since string is not POD, can't assume that it will optimize to O(1)
			concurrencies = priority_queue<short>();	// O(1), assuming optimization since value_type is POD
		=========================================================================================================================================================================

		So we have the outter while multiplying everyinig inside for N
			the first loop has only constant work inside so it runs Frosh_max

			build heap => Frosh_max*log(Frosh_max)

			create output by pop every value equal to max on heap => Frosh_max*log(Frosh_max)	// This is not a tight bound. For the worst case, all the concurrencies are 1. Heaps have constant time for heapify_down (bubble_down) when values are equal. So worst case should be Frosh_max, and best log(Frosh_max)
			
			output result => O(1)

			clear containers => O(Frosh_max)
		=========================================================================================================================================================================

		===> N*(Frosh_max + Frosh_max*log(Frosh_max) + Frosh_max*log(Frosh_max) + Frosh_max) ==> O(N*Frosh_max*log(Frosh_max))

	For the spatial analysis, we look at the containers, combinations can grow as much as the maximum number of students (Frosh_max). The heap grows in linear proportion as the number of combinations.

	So the complexity is O(Frosh_max)


*/

#include <iostream>
#include <unordered_map>
#include <queue>
#include <string>
#include <algorithm>

#define N_OF_CLASSES 5

using namespace std;

int main() {
	// containers for the combination, and the classes that the studends select
	// 1 <= n <= 10k,  -32k <= short <= 32k
	unordered_map<string, short> combinations;
	vector<short> classes(N_OF_CLASSES);

	// Var for number of students, and the classes id
	short frosh;
	short class_id;

	// This variable is so it uses string on the hash table
	string key_buffer;

	// Container for getting a fast top concurrencies (heap)
	priority_queue<short> concurrencies;
	short top_concurrency;
	short n_prize;

	// Read the number of students for the corresponding case
	while (cin >> frosh && frosh != 0) { // This will run N times, where N is the number of cases
		// For each student entry, read their classes selection
		for (int student=0; student<frosh; student++) {	// This runs frosh times, the number of students
			// Read the five classes
			for (int i=0; i<5; i++) {	// Runs 5 times (always)
				cin >> class_id;		// Not specified
				classes[i] = class_id;	// O(1)
			}

			// Sort the classes so its easy to save the combination
			sort(classes.begin(), classes.end());	// O(5*log(5)) = O(1) //*** Actually is O(25), because its less than the threshold size (15), and switches to insertion sort (but it is still constant)

			// It forms the key for the combination
			key_buffer = "";	// O(1)
			for (auto it=classes.begin(); it!=classes.end(); it++)	// This runs 5 times
				key_buffer += to_string(*it);	// Not specified, but could be linear on the resulting string length (on C++11)

			// It adds 1 to the combination concurrency
			if (combinations.find(key_buffer)!=combinations.end())	// O(1)
				combinations[key_buffer]++;							// O(1)
			// If this is the first concurrency, then create the data
			else
				combinations[key_buffer] = 1;						// O(1)

		}

		// Build the priority queue
		for (auto it=combinations.begin(); it!=combinations.end(); it++)	// At most the number of students
			concurrencies.push(it->second);		// O(log(n)) where n is the current size of the priority queue
		
		n_prize = 0;	// O(1)

		for (top_concurrency=concurrencies.top(); top_concurrency==concurrencies.top() && concurrencies.size(); concurrencies.pop())	// At most it will run the number of students
			n_prize += top_concurrency;		// O(1)
			// The next line is just the update statement of the for
			// concurrencies.pop()			// O(log(n)), where n is the size of the heap

		cout << n_prize << endl;			// Not specified

		// clear containers
		combinations.clear();						// O(n), where n is the size of the container... since string is not POD, can't assume that it will optimize to O(1)
		concurrencies = priority_queue<short>();	// O(1), assuming optimization since value_type is POD

	}

	return 0;
}