/*

Problem: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2407

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(1)	: Its actually O(n_coins!/((n_coins-n_holes)!)
	spatial: O(1)	: It stores the different coins and the current permutation, plus the inputs

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		initialize variables => O(1)

		read inputs => O(1)

		do
			build the coins for mixing => O(1)

			do
				check with first guess => O(1)
				check with second guess => O(1)
				if posible set flag and break => O(1)

				performe next permutation => O(2) => O(1)
			while next permutation => O(4!) => O(24) => O(1)

			if posible break => O(1)
	
			performe next permutation => O(3) => O(1)
		while there are permutations to try => O(15*24) => O(1)

		output result => O(1)
		=========================================================================================================================================================================

		So the complexity will be: O(1)

	For the spatial analysis, we look at the variables.
		The inputs are 2 strings of 4 characters (4*1byte) and 4 integers (32 bits).
		We save the possible coins (6 characters) a mask for the 4 holes selected (6 characters)
		And a table to map the coin to the corresponding position on the mask (6 pairs of character and short integer)

		All of this are constant spaces.

		The resulting complexity is:

		O(1)
*/

#include <string>
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

int main() {
	// Initialize variables
	string coins = "RGBYOV";			// O(1)
	string posible_solution(4, ' ');	// O(1)
	sort(coins.begin(), coins.end());	// O(1), because sorting a small CONSTANT amount of elements

	short t;
	string first_guess, second_guess;
	short f_n1, f_n2, s_n1, s_n2;

	bool posible;

	unsigned char mask[] = {0, 0, 1, 1, 1, 1};		// O(1)
		
	unordered_map<char, short> coins_map;
	for (int i=0; i<6; i++) coins_map[coins[i]] = i;// O(6) => O(1)

	cin >> t;
	for (int i=0; i<t; i++) {
		posible = false;					// O(1)
		cin >> first_guess >> f_n1 >> f_n2;	// O(1)
		cin >> second_guess >> s_n1 >> s_n2;// O(1)

		// Create all 15 posible permutations with 6 posibilities and 4 choices
		do {
			// We build the combination of coints
			short index = 0;								// O(1)
			for (int i=0; i<6; i++) {						// O(6)
				if (mask[i]==1)								// O(1)
					posible_solution[index++] = coins[i];	// O(1)
			}

			// We build the 24 possible permutations from the 4 coins selected and check if is a posible solution
			do {
				// We check the first guess
				short match = 0;	// O(1)
				short pressent = 0;	// O(1)

				// Count the number of matches and missplaces coins
				for (int i=0; i<4; i++) {						// O(4) => O(1)
					pressent += mask[coins_map[first_guess[i]]];// O(1)
					if (posible_solution[i] == first_guess[i])	// O(1)
						match++;								// O(1)
				}

				// If this is not a posible solution, then we continue with the next permutation
				if (match != f_n1 || pressent != f_n1+f_n2)		// O(1)
					continue;

				// We check the second guess
				match = 0;										// O(1)
				pressent = 0;									// O(1)

				// Count the number of matches and missplaces coins
				for (int i=0; i<4; i++) {							// O(4) => O(1)
					pressent += mask[coins_map[second_guess[i]]];	// O(1)
					if (posible_solution[i] == second_guess[i])		// O(1)
						match++;									// O(1)
				}

				// If this is a posible solution, then we found our answer
				if (match == s_n1 && pressent == s_n1+s_n2) {		// O(1)
					posible = true;									// O(1)
					break;
				}
			} while (next_permutation(posible_solution.begin(), posible_solution.end()));	// O(4!) => O(24) => O(1)	+ next_permutation O(2) => O(1)

			// If we found a posible solution, then we set the mask back to the sorted version and break the permutation cycle
			if (posible) {			// O(1)
				sort(mask, mask+6);	// O(1)
				break;
			}
		} while(next_permutation(mask, mask+6));											// O(15*24) => O(1)		+ next_permutation O(3) => O(1)

		// Output needed
		if (posible) cout << "Possible";	// O(1)
		else cout << "Cheat";				// O(1)

		// for online judge solution alignment
		cout << endl;						// O(1)
	}

	return 0;
}
