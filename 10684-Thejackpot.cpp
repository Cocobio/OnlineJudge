/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1625

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(N)	: Where N is the number of bets
	spatial: O(N)	: Where N is the number of bets

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		initialize variables => O(1)

		For each bet => O(N)
			read bet => O(1)

			update temporal streak and winning streak => O(1)

		output result => O(1)
		=========================================================================================================================================================================

		So the complexity will be:
			= O(N)

	For the spatial analysis, we look at the variables.
		The number of bets consist on a positive integer N <= 10000, which takes 4/log(2) bits ~= 14 bits => O(1)
		The bets are integers with a value of at most 1000, which takes 3/log(2) bits ~= 10 bits + 1 bit for negative values = 11 bits.

		There are a total of N bets => O(11*N) = O(N) for the input

		For the extra space needed for the algorithm, is about 5 variables (6 if we consider the i from the for loop) => O(1)

		So the total complexity for the space is O(N+1) = O(N)
*/

#include <iostream>

using namespace std;

int main() {
	unsigned short N;
	short bet;
	int winning_streak, tmp_streak, diff;
	int mask;

	// For faster input reading
	ios_base::sync_with_stdio(false);

	// Reads each case
	while (cin >> N && N!=0) {
		// Initialize the streak count
		tmp_streak = 0;							// O(1)
		winning_streak = 0;						// O(1)

		// For each bet
		for (int i=0; i<N; i++) {				// O(N)
			// read bet
			cin >> bet;							// O(1)

			// update temporal streak counter
			tmp_streak += bet;					// O(1)
			// if (winning_streak < tmp_streak) winning_streak = tmp_streak;	// O(1)
			// if (tmp_streak<0) tmp_streak = 0;								// O(1)

			// branch prediction work around
			// Got the same performance....

			// mask if the streak went on negative value
			mask = tmp_streak >> 31;			// O(1)
			// if negative, it sets the streak at 0
			tmp_streak = ~mask & tmp_streak;	// O(1)

			// Update the winning_streak
			// Saves the diff (it will be negative if tmp_streak > winning_streak)
			diff = winning_streak - tmp_streak;	// O(1)
			// Mask of ones if tmp_streak > winning_streak, pure 0 otherwise
			mask = diff >> 31;					// O(1)
			// sum the difference (update the new maximum winning_streak)
			winning_streak -= mask & diff;		// O(1)
		}

		// output
		if (winning_streak==0) cout << "Losing streak." << endl;						// O(1)
		else cout << "The maximum winning streak is " << winning_streak << "." << endl;	// O(1)
	}

	return 0;
}
