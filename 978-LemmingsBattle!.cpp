/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=919

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(N*((SG+SB))*log(SG*SB))	: Where N is the number of cases, SG and SB are the number of fighters for the green and blue team, B is the number of battlefields and n is the multiplication of SG*SB
	spatial: O(B+SG+SB)					: Where B is the maximum number of battlegrounds, SG is the maximum number of green fighters, SB is the maximum number of blue fighters. On the cases

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		for (int i=1; i<=N; i++)					// This runs N times, number of cases
			for (int j=0; j<SG; j++)				// O(SG)
				inside loop => O(1)
			construct heap with iters => O(n), where n is SG

			for (int j=0; j<SB; j++)				// O(SB)
				inside loop => O(1)
			construct heap with iters => O(n), where n is SB

			while (!green_team.empty() && !blue_team.empty()) 	// Runs at most ~(SG+SB)/B ****
				for (int j=0; j<B; j++)							// Runs B times (most of the times, the last ones might run a few less times.)
					inside loop => O(log(SG)) + O(log(SB)), at most SG and SB... As the algorithms runs, their sizes will shrink

				for (auto nurse=battlefield.begin(); nurse!=battlefield.end(); nurse++)		// Runs B times (most of the times)
					inside loop => O(log(n)), where n is the number of fighters on the container for the survivor team

			winner announce => O(nlog(n)), where n is the number of survivors on the winner team
		=========================================================================================================================================================================

		**** The while described at line 24 said that it will run at most (SG+SB)/B. This cames from the idea that on each iteration, the battlefields will be populated, and at minimum 1 lemming will die, per
		battlefield (both of them could die). So on each iteration, the total number of lemmings warriors (SG+SB) will be decremented at least by B. And how many times this will run until there are no more lemmings?
		At most ~(SG+SB)/B... (it could run a few more times, depending on the last fights and the matching between the teams... but lets not think about that). 

		* We will denote the max(SG, SB) when we announce a winner and when the "nurse" pushes the lemmings back to their heap team. Because it could be SG or SB, depending on the winner of the fight or the war.

		So if we analyze the complexities we have N * (SG + SG + SB + SB + (SG+SB)/B * (B * (log(SG) + log(SB)) + B * log(max(SG,SB))) + max(SG,SB)*log(max(SG,SB)))
		= N * (2*(SG+SB) + (SG+SB)/B * (B*log(SG*SB) + B*log(max(SG,SB))) + max(SG,SB)*log(max(SG,SB)) )  ==> O(N*(SG+SB)/B*(B*log(SG*SB))) = O(N*(SG+SB)*log(SG*SB))

	For the spatial analysis, we look at the variables, there are 4 container which that have spatial complexity of O(n). Each one saves the fighters of the teams, the battlefields and a tmp container.

*/

#include <iostream>
#include <queue>
#include <string>
#include <utility>

using namespace std;

// In wars there are no real winners
void announceWinner(string msg, priority_queue<char> &fighters) {	// O(nlog(n)), where n is the number of fighters. At most max(SG,SB)
	cout << msg << endl;						// Not defined

	// Announce all the survivors
	while (!fighters.empty()) {					// This will run fighters.size() times
		cout << (int)fighters.top() << endl;	// O(1)
		fighters.pop();							// O(log(n)), where n is fighters.size()
	}
}

// Getting savage!
void fight(char &green, char &blue) {	// O(1)
	if (green < blue) {			// O(1)
		blue -= green;			// O(1)
		green = 0;				// O(1)
	}
	else if (blue < green) {	// O(1)
		green -= blue;			// O(1)
		blue = 0;				// O(1)
	}
	else {
		green = 0;				// O(1)
		blue = 0;				// O(1)
	}
}

int main() {
	// Output strings
	string green_win = "green wins";
	string blue_win = "blue wins";
	string tied = "green and blue died";

	// Variables for the number of cases, number of battlegrounds, and number of fighters
	unsigned short N;
	unsigned B, SG, SB;

	// Containers for the teams and the battlefield
	vector<pair<char,char>> battlefield;
	priority_queue <char> green_team, blue_team;
	vector<char> temporal_container;

	// References for fighters
	char green_fighter, blue_fighter;
	short input_fighter;

	// Read number of cases
	cin >> N;

	// For each case
	for (int i=1; i<=N; i++) {	// This for loop will run N times, where N is number of cases
		// Read the number of battlefields, number of fighters on the green team and blue team
		cin >> B >> SG >> SB;

		// Read the fighters for the Green Team
		for (int j=0; j<SG; j++) {			// This loop will run SG times
			cin >> input_fighter;			// Not specify
			temporal_container.push_back(input_fighter);	// O(1)
		}
		green_team = priority_queue<char>(temporal_container.begin(), temporal_container.end());	// O(SG), this is linear when constructed with iterables
		temporal_container.clear();	// O(1), should be optimized because of the data type.

		// Read the fighters for the Blue Team
		for (int j=0; j<SB; j++) {			// This loop will run SB times
			cin >> input_fighter;			// Not specify
			temporal_container.push_back(input_fighter);	// O(1)
		}
		blue_team = priority_queue<char>(temporal_container.begin(), temporal_container.end());		// O(SB), this is linear when constructed with iterables
		temporal_container.clear();		// O(1), because char is PODs

		// FIGHT TO THE DEAD! Until one team gets obliterated
		while (!green_team.empty() && !blue_team.empty()) {	// This while loop will run at maximun (SG+SB)/B
			// It populates the battlefields with the fighters
			for (int j=0; j<B; j++) {								// This loop will run at maximun B times.
				// If one team has no fighters, this round ends
				if (green_team.empty() || blue_team.empty()) break;	// O(1)

				// Get the strongest fighters of each team
				green_fighter = green_team.top();	// O(1)
				blue_fighter = blue_team.top();		// O(1)

				green_team.pop();	// O(log(n)), where n is the size of the heap. At first SG
				blue_team.pop();	// O(log(n)), where n is the size of the heap. At first SB

				// They fight on the current battlefield
				fight(green_fighter, blue_fighter);	// O(1)

				// we leave the battlefield 
				battlefield.push_back(make_pair(green_fighter,blue_fighter));	// O(1) for the push_back. The make_pair complexity is not specify, but it should be O(1)
			}

			// Check for survivors! If found, get them to safety, so they can experience the horrors on the battlefield again (if need it)
			for (auto nurse=battlefield.begin(); nurse!=battlefield.end(); nurse++) {
				// Green survivor
				if (nurse->first) green_team.push(nurse->first);			// O(log(n)), where n is the number of fighters on the green_team container, at most SG

				// Blue survivor 
				else if (nurse->second) blue_team.push(nurse->second);		// O(log(n)), where n is the number of fighters on the blue_team container, at most SB
			}

			// Clean the battlefield
			battlefield.clear();	// O(n) on size, but could be O(1), since data is packed, and dont need deletion
		}

		// Declare winner and survivors
		if (green_team.size()) announceWinner(green_win, green_team);	// O(nlog(n)), where n is the number of survivors on the green team
		else if (blue_team.size()) announceWinner(blue_win, blue_team);	// O(nlog(n)), where n is the number of survivors on the blue team
		else cout << tied << endl;										// Not specify

		// empty line separating cases
		if (i!=N) cout << endl;		// Not specify
	}

	return 0;
}