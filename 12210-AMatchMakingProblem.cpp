/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3362

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(B+S)	: Where B is the number of bachelors and S is the number of spinsters
	spatial: O(1)		: The input is not read, but takes linear space on the number of bachelors and spinsters

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		output number of case => O(1)

		If there are less bachelors than spinsters
			output 0 as the bachelors left single => O(1)
			read the unused ages of the bachelors and spinsters => O(B+S) where B is the number of bachelors and S is the number of spinsters

		else
			prepare a reference minimum age => O(1)

			read bachelors ages while updating the minimum => O(B) where B is the number of bachelors
			read the unused ages of spinsters => O(S) where S is the number of spinsters

			output bachelors left single and the youngest => O(1)
		=========================================================================================================================================================================

		So the complexity will be: 
			if n of bachelors <= n of spinsters
				O(B+S)
			else
				O(B) + O(S) = O(B+S)

			= O(B+S)

	For the spatial analysis, we look at the variables.
		The ages are at most 60, so the space needed to store it is log(60)/log(2)
		The number of bachelors and spinsters are at most 10,000.

												  space for B and S                       (B+S) * space for ages
		To store the input the space needed is: 2*log(10000)/log(2) + atmost 2*10000*log(60)/log(2) = O(1)
		To solve the problem, the algorithm uses 2 integers of 16 bits for storing B and S. 3  integers of 16 bits to save the 
		number of the case, the minimum age and a temporal integer for reading the ages of the bachelors (when need it) = O(1)

		So the total complexity for the space is O(1), considering that B and S have a constant ceiling value.
*/

#include <iostream>

using namespace std;

int main() {
	short B, S;
	unsigned short cases = 1, tmp_age, min_age;

	// Most of the lost time will be on reading the S spinsters
	// with this the reading inputs will be faster
	ios_base::sync_with_stdio(false);

	while (cin >> B >> S && (B!=0 || S!=0)) {
		// Output for all the cases
		cout << "Case " << cases << ": ";				// O(1)

		// If there are less bachelors than spinsters, then there will be no bachelors left with out a future wife
		if (B<=S) {										// O(1)
			cout << 0;									// O(1)

			// Input still has to be taken out of the input buffer
			for (int i=0; i<B+S; i++) cin >> tmp_age;	// O(B+S)
		}
		else {
			// It reads one age and saves it as the minimum
			cin >> min_age;								// O(1)

			for (int i=1; i<B; i++) {					// O(B)
				cin >> tmp_age;							// O(1)
				if (tmp_age<min_age) min_age = tmp_age;	// O(1)
			}

			// Input for this case still needs to be taken out of the input buffer
			for (int i=0; i<S; i++) cin >> tmp_age;		// O(S)

			// Output the number of bachelors left single and the age of the youngest
			cout << B-S << " " << min_age;				// O(1)
		}

		cout << endl;		// O(1)
		cases ++;			// O(1)
	}

	return 0;
}
