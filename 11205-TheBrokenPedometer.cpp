/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2146

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: OO(2^P*(P+N*log(N)))	: Where P is the number of leds and N is the number of numbers
	spatial: O(N*P)					: Same as above

	** It could be considered as O(1) since P<=15 and N<=100. Both the temporal and spacial complexity

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		read number of leds and numbers => O(1)

		container for numbers set to 0s => O(N)

		Build the numbers => O(N*P)
		
		special case when N<2 => O(1)
		
		for each proper subset of leds => O(2^P*(P+N*log(N))) in the worst case
			create mask for subset => O(P)

			do
				create mask => O(P)

				sort numbers using mask => O(N*log(N))
				
				check undistinguishable numbers with mask => O(N)

				break if numbers are distinguishable => O(1)

				next permutation => O(P)
			while there is another proper subset => O(P!/(j!*(P-J)!))  => this is considered on the analysis for all the proper subsets of leds

			if is imposible to distinguish the numbers with this subset size, then break => O(1)

		Output => O(1)
		=========================================================================================================================================================================

		So the complexity will be: O(2^P*(P+N*log(N)))
			which is from trying all the proper subsets of P leds

	For the spatial analysis, we look at the variables.
		P, the number of leds is at most 15 which is constant (4 bits).
		N, the number of numbers is at most 100 (7 bits), and each number is represented with at most P bits (<= 15 bits).

		The container for all the numbers is N*P bits. Which is at most 1500 bits => 188 bytes.
		The container for masking all the proper subsets of the leds P * 1 bit (<= 15 bits)

		And the mask for the numbers is, P bits (<=15)

		The resulting complexity is:

		O(N*P)
*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int main() {
	// P <= 15 & N <= 100
	short cases, P, N;
	short c;

	// Read number of cases
	cin >> cases;

	for (int i=0; i<cases; i++) {
		// Read input about n of leds and numbers
		cin >> P >> N;						// O(1)

		// Numbers container
		vector<short> numbers(N, 0); 		// O(N)

		// Build the numbers
		for(auto &number:numbers)			// O(N*P)
			for(int k=0; k<P; k++) {		// O(P)
				cin >> c;					// O(1)
				number = (number << 1) + c;	// O(1)
			}

		// If low number of numbers
		if (N<2){							// O(1)
			cout << 0 << endl;				// O(1)
			continue;
		}
		
		// j will save the amount of leds on
		int j;

		// We assume that it can work with P leds, so we try with P-1 to 1
		for(j=P-1; j>0; j--) {					// O(2^P*(P+N*log(N))) in the worst case
			// initialize the subgroup mask with the lower lexicografic value
			vector<char> led_validator(P-j,0);	// O(P) with the one below
			led_validator.resize(P,1);			// in total the vector will start with P values set

			// flag will mark if this number of leds can 
			// distinguish all the numbers
			bool flag;
			do {
				// for masking the numbers with the working leds
				short mask = 0;
				for(auto &l:led_validator)		// O(P)
					mask = (mask<<1) + l;		// O(1)

				// Easier to check if numbers that can't be distinguished when they are sorted
				sort(numbers.begin(), numbers.end(), [&mask](short a, short b) -> bool { return (a&mask)<(b&mask); });	// O(N*log(N))
				
				// Chech if this combination of leds allows all the numbers to be distinguishable
				flag = true;
				for (int k=0; k<N-1; k++)		// O(N)
					if ((numbers[k]&mask) == (numbers[k+1]&mask)) {	// O(1)
						flag = false;								// O(1)
						break;
					}

				// If there is a posible combination, reduce the number of working leds
				if (flag) break;				// O(1)

			// check all posible permutations with 'j' working leds
			} while(next_permutation(led_validator.begin(), led_validator.end())); 	// O(P!/(j!*(P-J)!))  => this is considered on the analysis for all the proper subsets of leds
																					// O(P) => next permutation

			// For j working leds, there were no permutation of leds that made the numbers distinguishable
			if (!flag) break;					// O(1)
		}

		// Output
		cout << j+1 << endl; 					// O(1)
	}

	return 0;
}
