/*

Problem: https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2231

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(n)	: Where n is the number of coins, with an uppper bound of <=1000
	spatial: O(n)	: Same as above

	** It could be considered as O(1) since n <= 1000. Both the temporal and spacial complexity

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		initialize variables and read the number of coins => O(1)

		create cointainer for coins => O(1)

		read coints => O(n)

		inititialize counter and money sum => O(1)

		check the coins and build a max num => O(n)

		count the last coin => O(1)

		output => O(1)
		=========================================================================================================================================================================

		So the complexity will be: O(n)

	For the spatial analysis, we look at the variables.
		The number of coins is at most 1000, so at most log(1000)/log(2) => O(1)

		The values of the coins is at most 1000000000 => 30 bits (29.89).
		Container for all the coins is 30bits * n => O(n)

		The resulting complexity is:

		O(n)
*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
	int T;

	// Read the number of cases
	cin >> T;

	// Each case
	for(int cases=0; cases<T; cases++) {
		short n;
		cin >> n;

		// Coins container
		vector<unsigned> coins(n);			// O(1)

		// Read coints
		for(auto &c:coins)					// O(n)
			cin >> c;						// O(1)

		// Counter for coins and the amount of money ask
		short counter = 0;					// O(1)
		unsigned sum = 0;					// O(1)

		// Check if the coin i can be used, and the next coin
		// i+1 wont be payed by the sum using the ith coin
		for(int i=0; i<n-1; i++)			// O(n)
			if (sum+coins[i]<coins[i+1]) {	// O(1)
				counter++;					// O(1)
				sum += coins[i];			// O(1)
			}

		// The last coint that is not count
		counter++;							// O(1)

		// Output
		cout << counter << endl;			// O(1)
	}

	return 0;
}
