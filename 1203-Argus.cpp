/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3644

Ignacio Osorio Wallace
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O((K*log(n))	: Where K is the number of instructions to call, and n is the number of instructions inserted into Argus
	spatial: O(n)			: n is the number of instructions inserted into Argus

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		while (word.compare("#")!=0)	// This will multiply the internal complexity in n, the number of instructions given to Argus
			push_back on vector => O(1)
		build heap => O(n), where n is the number of instructions
		free tmp container => O(1), should be constant because instruction only contains PODs (its basically a struct) ***

		for (int i=0; i<K; i++)		// This will multiply the internal complexity with K
			Argus_query.top() => O(1)
			Argus_query.pop() => O(log(n)), where n is the number of instructions

			set next_pop => O(1)
			push with next pop => O(log(n)), where n is size of priority_queue
		=========================================================================================================================================================================

		So the complexity will be n + n + 1 + K*(1+log(n) + 1+log(n))
		= 2*n + 1 + 2*K*(1+log(n))	=	2*n + 2*K + 2*K*log(n) + 1	=	O(K*log(n))

		*** The complexity for clearing the container might be O(n), I'm assuming optimization on part of the compiler. But if it were, it wouldn't change the big O complexity.

		** by changing the method for building the heap. the complexity reduces from (n+k)*log(n) to K*log(n). And the time on the online judge goes down from 0.010 s to 0.000 s.
		** tradeof, we spend double the space for a breaf moment. In order to create the heap.

	For the spatial analysis, we look at the variables, there is only one container which has spatial complexity of O(n). And in this case n will be the number of instructions added to Argus.

*/

#include <iostream>
#include <queue>
#include <string>
#include <vector>

using namespace std;

// Class for saving Instruction under an Id, a time step, and the next time to be called
class Instruction {
public:
	unsigned short id;
	unsigned step;
	unsigned next_pop;

	Instruction() {}

	// Constructor for emplace function
	Instruction(unsigned short id, unsigned step, unsigned next_pop) {
		this->id = id;
		this->step = step;
		this->next_pop = next_pop;
	}

	// Operation overflow of greater, for the priority_queue
	// It selects the next instruction to be poped between this and b
	bool operator >(const Instruction &b) const {
		return next_pop>b.next_pop || (next_pop==b.next_pop && id>b.id);
	} 
};

int main() {
	// Since it uses its own Data struct, the heap must specify the value_type, container, and comparator that it needs
	priority_queue<Instruction, vector<Instruction>, greater<Instruction>> Argus_query;
	vector<Instruction> temporal_container;
	Instruction tmpReg;

	// Input data
	string word;
	unsigned short id;
	unsigned step;
	int K;

	// Reads the first word, for the sake of the simplicity of the while
	cin >> word;

	// It compares the word read, so when it reads the character '#' it will stop
	while (word.compare("#")!=0) {	// This will multiply the internal complexity in the number instructions given to Argus
		// Read id of the register, and the time step that will use, then reads the first word of the next line
		cin >> id >> step >> word;	// Not specify

		// It adds the register to a priority_queue
		temporal_container.push_back(Instruction(id,step,step));	// O(1)
	}

	Argus_query = priority_queue<Instruction, vector<Instruction>, greater<Instruction>>(temporal_container.begin(), temporal_container.end());	// O(n), because its using the construct with iterables
	temporal_container.clear();	// O(1) for optimization on PODs
	
	// Read the number of output asked
	cin >> K;	// Not specify

	for (int i=0; i<K; i++) {	// This will multiply the internal complexity with K
		// It takes the next instruction that needs to be attend, outputs it
		tmpReg = Argus_query.top();	// O(1)
		Argus_query.pop();			// O(log(n)), where n is the number of instructions given to Arguns (aka size of priority_queue)
		cout << tmpReg.id << endl;	// Not specify

		// It re schedule the instruction using the step that uses. Then it pushes it back to the priority_queue
		tmpReg.next_pop += tmpReg.step;	// O(1)
		Argus_query.push(tmpReg);		// O(log(n)), where n is size of priority_queue
	}

	return 0;
}