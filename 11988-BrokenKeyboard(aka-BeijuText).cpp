/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3139

Ignacio Osorio Wallace
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(cases*line_size)	: Where cases are the number of lines on the input, and line_size is the average size for the lines
	spatial: O(line_size)			: Where line_size is the avr size of the input line.

	For the temporal analysis, all the complexities are commented right next to all of the lines.
	
		=========================================================================================================================================================================
		while (getline(cin, input_line)) 	// This will multiply the internal complexity in the number of lines read (or cases)
			set insert at begin => O(1)

			for (auto it=input_line.begin(); it!=input_line.end(); it++)	// this will multiply the internal complexity in input_line.size()

				if home or end button, set insert position => O(1)

				else insert char => O(1)

			build output string with list => O(n)

			clear list => O(n)
		=========================================================================================================================================================================

		So the complexity will be cases*(1 + line_size*(1+1) + line_size + line_size) = O(cases*line_size)
		Since each line might have different sizes, I'll assume line_size as the average size for the input lines

	For the spatial analysis, we look at the variables, there is only one container which has spatial complexity of O(n). And in this case n will be the size of each line read, or, lets say the avr.

*/

#include <iostream>
#include <list>
#include <string>

using namespace std;

int main() {
	// variables for input, and working
	string input_line;
	list<char> screen_text;
	string beiju_output;

	// the characters that represent the home and end button
	char home_button = '[';
	char end_button = ']';

	// for each line we read the input
	while (getline(cin, input_line)) {	// This will multiply the internal complexity in the number of lines read
		// Set the position of the text at the begining of our output text (the one on the screen)
		list<char>::iterator text_position = screen_text.begin();	// O(1)

		// Iterate though all the caracters and insert all of them that are not home or end button. If home or end are found, set position of the text inserted to the begining or end (depending on which button was found).
		for (auto it=input_line.begin(); it!=input_line.end(); it++) {	// this will multiply the internal complexity in input_line.size(), which we will call size_i

			// If character represents the home button, it sets the position at the begining of the text
			if (*it == home_button)						// O(1)
				text_position = screen_text.begin();	// O(1)

			// If character represents the end button, it sets the position at the end of the text
			else if (*it == end_button)					// O(1)
				text_position = screen_text.end();		// O(1)

			// Insert the character if its not home or end button
			else
				screen_text.insert(text_position, *it);	// O(1)
		}

		// Build a string with the list of characters
		beiju_output = string(screen_text.begin(), screen_text.end());	// O(n) where n is screen_text.size(), which is at most input_line.size() elements

		// Output the beiju text
		cout << beiju_output << endl;	// Not specify, could be O(n), where n is the number of bytes to be copied to the buffer?

		// clean container
		screen_text.clear();	// O(n) where n is screen_text.size(), again, at most input_line.size()
	}

	return 0;
}