/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=455

Ignacio Osorio Wallace
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(c*N*x)	: where c is the number of cases, N is the average number of vagon on the cases, and x is the average number of diff. combinations given on the cases
	spatial: O(N)		: where N is the average size of vagons given. The space will be at most 4 times that size, and at least ~3 times.

	For the temporal analysis, all the complexities:

		=========================================================================================================================================================================
		while (cin >> N && N!=0) c times, where c is the number of cases
			for (int i=1; i<=N; i++) N_i vagons => O(N_i)
				inside for loop => O(1) amortized

			while (cin >> tmp && tmp != 0) x times, where x_i is the number of combinations for a N_i vagon
				for (int i=1; i<N; i++) N_i vagons => O(N_i)
					inside for loop => O(1) amortized

				trainChief => O(N_i)

				cleaning => O(1) we'll assume that the delete its optimized (although it wont make the complexity grow)
			
			cleaning => O(1) we'll assume that the delete its optimized (although it wont make the complexity grow)
		=========================================================================================================================================================================

		So it will be c * (N_i + x_i * (N_i + N_i + 1) + 1) = O(c*x_i*N_i)

	For the spatial analysis, we look at the variables, there are 4 containers that will hold at most all the vagons. Line in and combinations are N size, and station stack and the output queue are at most N.

*/

#include <iostream>
#include <vector>
#include <stack>

using namespace std;

// Function that works as the train chief. It will use the station to sort the vagons on the correct combination. If sucessed all the vagons will be on the line_out.
// If its not posible, it will clean the station, and leave everything as it is. ** The line_out will not contain all the vagons. **
// **** Each vagon coming from line in will be processed one unique time from the line in, trasported to the station or the out line.
// **** Each vagon going inside the station will be processed at most one unique time, if the combination is possible.
void trainChief(vector<short> &line_in, vector<short> &line_out, stack<short> &station, vector<short> &combination) {	// O(n) where n is the number of vagons.
	// iterator for input vagons
	short coach_at_line_in = 0;

	// Since the combination contains the needed vagon, it will iterate throught trying to push the vagon needed
	for(auto it=combination.begin(); it!=combination.end(); it++) {	// This will multiply the internal complexity with combination.size() which is N, the number of vagons
		// If it stills have vagons on the input line and the current vagon on the line is the next one for the combination, then push it to the output line
		if (coach_at_line_in<line_in.size() && *it == line_in[coach_at_line_in]) {	// O(1)
			line_out.push_back(line_in[coach_at_line_in++]);		// push_back = O(1) amortized time, [] operator = O(1)
		}

		// else, if the needed vagon, is further on the line_in. Push all the in-between vagons into the station. And push the needed vagon into the output line
		else if (coach_at_line_in<line_in.size() && *it>line_in[coach_at_line_in]) {	// O(1)
			while(*it != line_in[coach_at_line_in]) {				// This will multiply the internal complexity with at most N, where N is the number of vagons. But it will run a total of N times for the entire For loop.
				station.push(line_in[coach_at_line_in++]);			// push_back = O(1) amortized time, [] operator = O(1)
			}

			line_out.push_back(line_in[coach_at_line_in++]);		// push_back = O(1) amortized time, [] operator = O(1)
		}

		// If the needed vagon is on the station
		else {
			// If the vagon can be accessed, then push it to the output line
			if (*it==station.top()) {								// O(1)
				line_out.push_back(station.top());					// push_back = O(1) amortized time, top = O(1)
				station.pop();										// O(1)
			}

			// If the vagon CAN'T be accessed, then this combination is not posible. So the chief has to clean the station, and the output line wont have all the vagons
			else {
				// If the combination is not posible, chief will clean the station and return
				while (station.size()) station.pop();				// This will run at most N-1 times O(N-1), pop = O(1)
				return;
			}
		}
	}
}

int main() {
	// Containers for simulating the push-pop city station problem
	vector<short> line_a;
	vector<short> line_b;
	stack<short> poppush_city_station;

	// Container for the combinations
	vector<short> desired_combination;

	// Number of vagons and a tmp variable for cin
	short N;
	short tmp;

	// Read cases, while they are available.
	while (cin >> N && N!=0) {		// This run as many time as different cases are presented (considering a case as one N number of vagons and x number of combinations)
		// It initializes the in line
		for (int i=1; i<=N; i++)	// This multiplies the inside complexity with N, where N is the number of vagons
			line_a.push_back(i);	// push_back = O(1) amortized time

		// Read combinations until end of block is found (cin = 0)
		while (cin >> tmp && tmp != 0) {		// This will run x times, where x is the number of different combinations given for this particular N sized-vagon problem
			desired_combination.push_back(tmp);	// push_back = O(1) amortized time

			// it reads the rest of desired combination
			for (int i=1; i<N; i++) {			// This will run N times, where N is the number of vagons
				cin >> tmp;						// Complexity not specify
				desired_combination.push_back(tmp);	// push_back = O(1) amortized time
			}

			// The train chief will try to organize the vagons using the combination as sheet
			// If the train chief succeeds, then all the vagons will be on the line_b
			// If not, the number of vagons on the line_b will be less than the total number of vagons
			trainChief(line_a, line_b, poppush_city_station, desired_combination);	// O(n), where n is the number of vagon. The details are on the function description on top.

			// Chech whether the train chief succeeded
			if (line_b.size() == N)		// O(1)
				cout << "Yes" << endl;	// Not specify
			else 
				cout << "No" << endl;	// Not specify

			// It cleans all the containers
			line_b.clear();					// O(n) where n is at most N (number of vagons), BUT! it could be optimized to O(1) since the data type does not need to be destroyed
			desired_combination.clear();	// O(n) where n is N (number of vagons), BUT! it could be optimized to O(1) since the data type does not need to be destroyed
		}
		
		// It cleans the line_a
		line_a.clear();		// O(n) where n is N (number of vagons), BUT! it could be optimized to O(1) since the data type does not need to be destroyed

		// cout for format
		cout << endl;		// Not specify
	}

	return 0;
}