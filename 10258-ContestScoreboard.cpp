/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1199

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(cases*N)	: Where cases is the number of different cases, N is the number of entries. I'm simplifying the analysis by saying that n is the number of contestants that presented problems (at most 100) so const.
	spatial: O(n)			: Where n is the number of contestants

	For the temporal analysis, all the complexities are commented right next to all of the lines. 

		=========================================================================================================================================================================
		for (int i=0; i<=cases; i++)	// This will run cases time (number of cases)
			while (getline(cin, s_stream) && s_stream.size()!=0) {	// This will run N times, where N is the number of entries
				
				if new contestant => O(1), hash table

				Ignore solved problems => O(1), hash table

				if entry marks as C or I => O(1), hash table
			
			build sorting container => O(n), where n is the number of contestants

			sort the scores => O(nlog(n)), where n is the number of contestants

			output ranking => O(n), where n is the number of contestants

			cleaning containers => O(n)
		=========================================================================================================================================================================

	So outter for, is a factor of cases times. The while is N, where N is the number of entries. Inside this while we have a lot of log(n) operations, where n is the number of contestants.
	Outside the while, all the operations are on based on the number of contastants, where the one with bigger order being the nlog(n) for sorting.

	So in total we have O(cases * (N + nlog(n))), where n is at most 100 and N has no limit defined. So we drop the nlog(n). ***** IF THE NUMBER OF CONTESTANTS ARE NOT FIXED TO A MAXIMUN, THE nlog(n) its important!
	Total complexity O(cases*N)
		
	For the spatial analysis, we look at the containers. We use 2 unordered_maps and 1 vector. All of them will have at most n elements, where n is the number of contestants.
	And also, n is at most 100. The unordered_map will use more than n size, but will be linearly proportional to n.
		where n is the number of contestants.

*/

#define N_PROBLEMS 9

#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <vector>
#include <array>
#include <sstream>

using namespace std;

// This functions will evaluate which user must be first. The one with more problems solves. If they have the same number, the one with less time penalty. If the time penalty is equal, then the one with the smaller id.
bool eval(pair<int,pair<int,int>> a, pair<int,pair<int,int>> b) {	// O(1)
	// value.first = ID, value.second.first = Number of problems solved and value.second.second = time penalty
	return a.second.first>b.second.first || (a.second.first==b.second.first && (a.second.second<b.second.second || (a.second.second==b.second.second && a.first<b.first)));
};


// podria cambiar el vector de un monton de pares, por un vector<array<int,3>>
int main() {
	int cases;
	char c;
	int contestant_id, problem_id;
	int time;

	// <id, advances on problems> container
	unordered_map<short,array<int,N_PROBLEMS>> problems_student;
	// temporal reference for new contestant
	array<int,N_PROBLEMS> problems_tmp;

	// <id, {score, time penalty}> containers for the contestant score, ordered by their id
	unordered_map<int,pair<int,int>> score_board;

	// for ordering the score board
	vector<pair<int,pair<int,int>>> sorting_container;

	string s_stream;

	// Read number of cases
	cin >> cases;

	// Read empty line
	// Not working well, it will be read inside the for. Thats why the for loop runs cases+1 time.
	getline(cin, s_stream);

	// Analyse each case
	for (int i=0; i<=cases; i++) {	// This will run cases time (number of cases)

		// Each case. Read the entries until an empty line
		while (getline(cin, s_stream) && s_stream.size()!=0) {	// This will run N times, where N is the number of entries
			// It reads the contestant id, problem_id, time and status from the entry string
			stringstream s(s_stream);						// Not specified
			s >> contestant_id >> problem_id >> time >> c;	// Not specified

			// If the contestant id is new, it creates a new array for his/her advances on the problems
			if (score_board.find(contestant_id)==score_board.end()) {	// O(1)
				score_board.emplace(contestant_id, make_pair(0,0));		// O(1)
				problems_tmp = array<int,N_PROBLEMS>();					// O(1)
				problems_tmp.fill(0);									// O(1), its linear in number of elements, but the number of elements are 9 always, so its const

				problems_student[contestant_id] = problems_tmp;			// O(1)
			}
			
			// -1 is the flag for problems already solved, so it ignores this entry
			if (problems_student[contestant_id][problem_id-1] == -1) continue;	// O(1)

			// If the problem has been flagged as correct, it increases the number of problems solved. It calculates the time penalty. And sets the problems as already solved (-1)
			else if (c == 'C') {																			// O(1)
				score_board[contestant_id].first += 1;														// O(1)
				score_board[contestant_id].second += problems_student[contestant_id][problem_id-1] + time;	// O(1)
				problems_student[contestant_id][problem_id-1] = -1;											// O(1)
			}

			// If the entry has been flagged as incorrect, it increases the time penalty for this problem.
			else if (c == 'I') {										// O(1)
				problems_student[contestant_id][problem_id-1] += 20;	// O(1)
			}
		}
		
		// Once all the entries have been read. The final scores are ready to be ranked.
		// They are pushed into a container for sorting. Since maps are unmutables
		for (auto it=score_board.begin(); it!=score_board.end(); it++) 	// all this for runs with O(n), where n is the number of contestants
			sorting_container.push_back(*it);

		// Introsort to rank the contestants
		sort(sorting_container.begin(), sorting_container.end(), eval);	// O(nlog(n)), where n is at most 100... so it could be conosidered O(1)

		// Output the ranking
		for (auto it=sorting_container.begin(); it!=sorting_container.end(); it++)				// This for has complexity O(n), where n is the number of contestans.
			cout << it->first << " " << it->second.first << " " << it->second.second << endl; 	// Not specified

		// Clean the containers
		score_board.clear();		// O(n), where n is the number of contestants
		problems_student.clear();	// O(n), where n is the number of contestants
		sorting_container.clear();	// It could be O(1), since the data type is a pack of PODs build as structs with pair.

		// Line in between cases. For format purposes.
		if (i!=0 && i!=cases) cout << endl;	// Not specified
	}

	return 0;
}