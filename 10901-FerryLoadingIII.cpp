/*

Problem: https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1842

Ignacio Osorio
Cocobio2

Generated by Ignacio Osorio Wallace

Asymptotic analysis of solution:
	temporal: O(cases*cars_n)	: Where cases is the number of cases and cars_n is the number of cars that want to cross the river and ferry_n is the capacity of the ferry.
	spatial: O(n)				: Where n is the maximum number of cars that arrive at the cases. 

	For the temporal analysis we look at the code:
	
		=========================================================================================================================================================================
		for (int  i=1; i<=cases; i++) {	// This will run cases time

			create output vector => O(1?) It doesn't specify.

			for (int j=0; j<cars_n; j++)	// This runs cars_n times
				read and push car on lane => O(1)

			set time and ferry start side => O(1)

			// ** Here we assume that the worst case is that the ferry takes only 1 car at a time and all arrive on the same side. So it will run 2 times the maximum number of car (in the worst case)
			while (!left_lane.empty() || !right_lane.empty()) // At most 2*cars_n which is linear on cars_n
				set references => O(1)

				load ferry if posible => O(ferry_n) // ** but in the while worst case, this would be constant, because it would only load 1 car
				if not, fastforward time => O(1)

				ferry crosses => O(1)

				Unload the ferry => O(ferry_n) // ** but in the while worst case, this would be constant, because it would only load 1 car

			for (auto it=output_cars.begin(); it!=output_cars.end(); it++)	// O(cars_n)
		=========================================================================================================================================================================

		So we can formulate our complexity as: cases * (1 + cars_n + 1 + cars_n*(2+2*ferry_n)+cars_n) = cases * (2*cars_n*ferry_n + 4*cars_n + 2) 
		* The amount of iterations from the while on line 27 will decresed on the numbers of cars transported by the ferry, at lines 30 and 35. So the amount of work will be shared.
		From this we can see that the complexity will be linear on the number of cars. And the sizes of the ferry will take part of the computational load from the while and move it to the loading and unloading of the ferry.
		** The amount of work on 27 is shared with the amount of work on 30 & 35. BECAUSE EACH CAR WILL BE TRANSPORTED ONE UNIQUE TIME.

		==> O(cases*cars_n), where cases is the number of cases and cars_n is the number of cars that want to cross the river

	For the spatial analysis, the sum of elements on both sides of the rives are the number of cars that arrived, and the output is also of the same size. The ferry its of at most ferry_n size.
		So the total complexity is linear on the number of cars and size of the ferry. If ferry size is greater than the number of cars, and all the cars arrive at the same size, the maximum size for the ferry 
		would be the maximum number of cars. 

		This means the spatial complexity is bould linearly by the number of cars.
		O(n), where n is the maximum number of cars on the cases

*/

#include <iostream>
#include <vector>
#include <deque>
#include <string>

using namespace std;

// Instead of using a pair, it creates it own class car, that saves the time of arrival and the number on the original queue (order of arrival)
class car {
private:
	int car_id;
	int car_arrive_t;
public:
	car() {}
	// For emplace constructor
	car(int id, int t) { 
		car_id=id;
		car_arrive_t = t;
	}

	int get_id() { return car_id; }
	int get_t() { return car_arrive_t; }
};

// Using the container ferry, to load the cars on the selected side (current_lane), at a particular momento of the day (current_t).
void loadFerry(int &current_t, deque<car> *current_lane, deque<car> &ferry, int ferry_capacity) {	// O(ferry_capacity)
	car car_i;

	// if we have to wait, it fastforwards to the new car
	if ((*current_lane).front().get_t() > current_t) current_t = (*current_lane).front().get_t();	// O(1)

	// load at most ferry_capacity cars. Cars must be waiting or just arrived.
	for (int i=0; (*current_lane).size() && i<ferry_capacity && (*current_lane).front().get_t()<=current_t; i++) {	// This runs at most ferry_capacity times
		car_i = (*current_lane).front();	// O(1)
		(*current_lane).pop_front();		// O(1)
		ferry.push_back(car_i);				// O(1)
	}
}

int main() {
	// variables for number of cases and time of the day
	int cases;
	int current_t;

	// Ferry capacity, time that it takes the ferry to cross the river, and number of cars that will arrive to the sides
	int ferry_n;
	int ferry_t;
	int cars_n;

	// vars for read and work
	string car_lane;
	int car_t;

	// Containers for simulating the river roads and the ferry
	deque<car> left_lane;
	deque<car> right_lane;
	deque<car> ferry;

	// Container so it doesn't re orders. 
	vector<int> output_cars;
	
	//Var to save on which side the ferry is at.
	bool ferry_current_side;

	// References
	deque<car> *current_lane, *other_lane;

	cin >> cases;

	for (int  i=1; i<=cases; i++) {	// This will run cases time
		cin >> ferry_n >> ferry_t >> cars_n;	// Not specified

		output_cars = vector<int>(cars_n);		// O(1?) It doesn't specify.

		// Populate the lanes
		for (int j=0; j<cars_n; j++) {	// This runs cars_n times
			cin >> car_t >> car_lane;	// Not specified

			if (car_lane.compare("left") == 0)		// O(1)
				left_lane.emplace_back(j,car_t);	// O(1)

			// We only get left or right
			else 
				right_lane.emplace_back(j, car_t);	// O(1)
		}

		// it starts at the begining of the day, with the ferry on the left side
		current_t = 0;					// O(1)
		// false = left, true = right
		ferry_current_side = false;		// O(1)

		// The ferry will transport them until no more cars to transport
		while (!left_lane.empty() || !right_lane.empty()) {	// This will run at most 2*cars_n, when all the cars arrive at one lane, and with times that the ferry only trasports one at a time.
			// We set our current position
			if (ferry_current_side) {		// O(1)
				current_lane = &right_lane;	// O(1)
				other_lane = &left_lane;	// O(1)
			}
			else {
				current_lane = &left_lane;	// O(1)
				other_lane = &right_lane;	// O(1)
			}

			// Load ferry
			if ((*current_lane).size() && ((*current_lane).front().get_t() <= current_t || ((*other_lane).empty() || (*current_lane).front().get_t() <= (*other_lane).front().get_t())))	// O(1)
				loadFerry(current_t, current_lane, ferry, ferry_n);		// O(ferry_n)

			// If there are no cars to be loaded and the next car its on the other side, it fastforward to the arrival of the car on the other side
			else if ((*other_lane).front().get_t()>current_t)	// O(1)
				current_t = (*other_lane).front().get_t();		// O(1)


			// Time that takes the ferry to cross
			current_t += ferry_t;						// O(1)
			// The ferry crosses to the other side
			ferry_current_side = !ferry_current_side;	// O(1)

			// Unload the ferry
			for (auto it=ferry.begin(); it!=ferry.end(); it++, ferry.pop_front()) // this runs at most ferry_n times
				output_cars[(*it).get_id()] = current_t;	// O(1)
		}

		// Output the times when the cars were unloaded on the other side
		for (auto it=output_cars.begin(); it!=output_cars.end(); it++)	// This runs cars_n times
			cout << *it << endl;	// Not specified

		// output line between cases
		if (i!=cases) cout << endl;	// Not specified
	}

	return 0;
}